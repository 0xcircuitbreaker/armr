static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\305"
#define      date_z	1
#define      date	((&data[1]))
	"\176"
#define      tst2_z	19
#define      tst2	((&data[5]))
	"\135\033\115\266\341\001\214\241\003\135\374\170\220\213\245\015"
	"\301\302\146\166\115\275\262\240\355\220"
#define      chk2_z	19
#define      chk2	((&data[32]))
	"\040\147\176\306\025\014\307\235\167\364\332\054\357\355\104\335"
	"\066\335\347\107\107\244\045\375\364\207"
#define      xecc_z	15
#define      xecc	((&data[55]))
	"\347\251\354\356\064\210\055\346\230\152\345\102\373\127\055\340"
	"\162\074\044"
#define      tst1_z	22
#define      tst1	((&data[75]))
	"\242\122\336\275\146\141\024\075\356\363\130\123\103\350\071\276"
	"\236\143\346\156\256\062\303\133"
#define      opts_z	1
#define      opts	((&data[97]))
	"\147"
#define      pswd_z	256
#define      pswd	((&data[148]))
	"\204\263\363\147\223\267\210\373\066\117\371\052\326\133\226\246"
	"\102\010\342\146\171\121\151\034\244\063\226\124\027\134\267\233"
	"\020\252\003\244\142\214\240\230\333\231\303\262\364\131\130\066"
	"\141\073\064\127\202\342\264\325\150\071\007\312\233\265\270\226"
	"\076\052\013\335\041\102\305\202\235\375\264\374\314\070\251\167"
	"\203\335\316\006\277\203\333\050\274\343\362\127\231\252\356\330"
	"\324\371\266\365\074\173\170\331\171\055\326\105\145\177\274\351"
	"\135\213\357\035\016\313\105\313\257\067\043\111\342\021\041\266"
	"\013\327\254\107\122\044\041\313\122\367\020\267\167\315\240\324"
	"\130\220\362\146\134\067\062\013\157\125\124\121\146\165\010\162"
	"\115\264\271\237\331\332\153\053\322\174\343\111\111\204\036\241"
	"\024\020\010\160\110\072\174\267\220\320\010\367\106\020\151\223"
	"\305\042\063\236\375\237\312\317\033\255\030\144\061\067\006\106"
	"\107\016\266\220\111\062\107\331\003\117\320\111\137\072\335\044"
	"\134\021\303\131\260\216\050\313\073\101\057\155\171\066\263\301"
	"\105\152\121\216\235\230\150\241\347\071\353\107\163\310\154\320"
	"\332\060\052\212\276\122\125\372\224\205\147\015\273\033\317\001"
	"\206\040\217\044\270\370\305\240\061\261\350\245\172\124\166\124"
	"\204\240\336\103\362\064\075\207\271\245\225\165\301\144\166\107"
	"\205\006\235\333\215\007\370\061\072\216\205\122\353\075\356\374"
	"\347\361\240\111\176\100\341\132\331\244\014"
#define      text_z	708
#define      text	((&data[605]))
	"\004\137\241\242\073\056\251\064\137\344\302\345\066\256\042\044"
	"\252\011\026\113\123\224\213\065\356\145\331\373\064\327\141\070"
	"\067\002\333\163\061\204\247\220\151\152\166\237\030\230\303\303"
	"\242\331\016\365\156\232\052\134\000\004\130\064\334\271\155\024"
	"\274\110\207\355\315\057\175\066\232\363\326\263\214\231\166\056"
	"\163\205\044\341\037\116\076\040\123\227\124\057\120\302\103\014"
	"\012\313\372\330\373\170\017\225\154\345\110\370\176\276\047\362"
	"\103\113\323\143\232\022\204\356\251\330\035\372\233\141\007\246"
	"\054\001\176\050\171\215\275\346\163\005\336\361\303\006\344\007"
	"\122\270\153\354\312\357\332\164\310\370\156\143\131\165\011\206"
	"\167\210\256\361\026\154\327\211\161\266\173\065\274\137\075\016"
	"\106\247\301\330\221\357\300\162\374\337\327\164\073\276\335\103"
	"\334\310\377\336\310\035\037\330\323\306\107\213\361\043\061\050"
	"\003\313\147\231\274\151\135\305\174\141\167\156\000\250\222\100"
	"\162\050\325\271\257\130\115\046\317\253\235\115\114\341\151\004"
	"\243\370\223\007\275\206\170\130\224\204\222\205\367\176\052\211"
	"\001\307\224\000\163\355\002\023\034\224\124\240\202\155\133\175"
	"\111\370\130\326\311\234\262\277\302\236\254\362\304\233\166\202"
	"\044\213\075\123\146\343\225\166\314\104\357\214\024\152\242\255"
	"\267\115\357\306\363\251\114\150\034\370\236\043\221\244\253\037"
	"\073\371\161\312\024\074\217\371\033\023\040\001\036\220\350\162"
	"\112\145\207\233\151\271\126\276\350\212\311\131\041\042\100\303"
	"\222\136\042\207\220\151\127\124\074\135\216\302\062\320\226\335"
	"\066\340\125\071\020\130\274\141\374\367\215\171\332\263\236\205"
	"\237\323\144\141\365\215\320\006\002\011\072\156\007\023\325\116"
	"\236\057\132\066\110\357\031\012\273\134\134\012\131\222\040\140"
	"\062\135\171\255\224\037\160\076\035\053\300\021\056\263\151\202"
	"\016\151\043\266\323\366\151\354\261\277\353\370\337\337\121\336"
	"\304\105\350\302\215\203\104\317\067\344\071\325\127\254\220\031"
	"\245\261\021\327\147\122\312\324\321\022\044\103\271\110\374\006"
	"\362\115\066\242\255\377\321\351\170\241\154\046\361\113\373\125"
	"\141\253\336\345\067\126\022\353\227\112\023\224\000\263\300\344"
	"\325\174\364\005\214\136\275\175\061\346\061\304\212\235\226\325"
	"\364\025\236\305\305\372\213\266\001\132\057\271\234\256\301\011"
	"\004\367\350\257\057\324\107\341\312\035\213\316\241\344\333\162"
	"\307\226\041\221\302\254\146\274\214\015\336\271\261\332\277\026"
	"\055\202\330\204\155\301\361\030\031\371\266\347\360\227\375\240"
	"\177\014\343\227\237\236\001\336\026\246\054\150\150\174\307\343"
	"\376\144\046\376\065\137\275\066\263\115\236\316\201\016\131\166"
	"\056\116\257\223\263\255\245\304\362\270\320\022\136\025\155\304"
	"\326\064\132\067\277\052\014\142\226\265\251\357\210\274\324\032"
	"\131\322\371\155\112\001\255\213\261\122\237\021\001\163\235\337"
	"\224\263\131\351\137\153\166\116\100\077\116\266\200\136\023\004"
	"\366\010\060\021\024\236\301\010\054\125\142\331\343\244\274\301"
	"\162\051\342\004\241\036\243\013\045\040\007\270\175\361\274\220"
	"\106\046\210\002\006\102\165\233\010\025\106\130\176\054\000\253"
	"\001\212\063\357\052\033\240\061\367\157\165\156\210\070\030\237"
	"\122\170\110\075\321\332\262\270\356\300\105\326\361\012\253\226"
	"\207\140\110\343\232\142\206\213\365\072\340\357\215\115\234\013"
	"\377\123\065\360\206\047\207\256\073\151\175\333\030\333\273\035"
	"\272\016\333\233\243\354\301\376\126\016\021\373\210\363\342\221"
	"\237\144\220\115\200\273\343\211\236\203\237\261\367\101\226\277"
	"\244\241\032\017\167\040\335\257\373\012\230\362\000\364\150\201"
	"\252\250\005\336\112\061\237\252\375\042\007\304\315\122\133\006"
	"\217\020\034\024\127\147\032\014\105\122\304\103\213\137\377\373"
	"\041\120\136\304\027\250\373\342\230\326\127\141\316\305\304\050"
	"\073\316\257\262\127\136\244\155\312\173\367\074\061\162\161\356"
	"\322\256\375\352\127\370\315\357\317\044\120\235\351\025\306\045"
	"\344\166\327\074\325\174\252\237\367\241\333\051\024\115\030\346"
	"\373\025\320\122\016\235\102\335\301\222"
#define      chk1_z	22
#define      chk1	((&data[1387]))
	"\101\320\215\270\110\130\300\303\011\073\146\221\361\176\352\031"
	"\206\113\254\245\071\333\027\143\173\122\250\311\215"
#define      shll_z	10
#define      shll	((&data[1413]))
	"\034\225\206\157\024\014\263\343\137\067\115"
#define      msg1_z	65
#define      msg1	((&data[1423]))
	"\171\020\032\335\103\135\201\377\060\377\363\133\221\217\276\031"
	"\336\310\064\275\007\000\331\245\141\004\351\070\076\263\324\104"
	"\322\261\144\107\315\054\120\146\336\065\245\374\155\110\164\146"
	"\321\171\260\145\337\310\230\305\126\026\142\344\011\174\320\316"
	"\115\051\126\136\017"
#define      inlo_z	3
#define      inlo	((&data[1492]))
	"\245\002\300"
#define      msg2_z	19
#define      msg2	((&data[1497]))
	"\346\137\237\224\047\155\226\121\327\373\266\332\376\365\025\335"
	"\377\322\221\157\166\100\171"
#define      rlax_z	1
#define      rlax	((&data[1518]))
	"\270"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
